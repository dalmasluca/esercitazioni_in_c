Certamente, ecco la traduzione del file Markdown per il "Lab 04" in modo che sia compatibile con il linguaggio C. Le sezioni specifiche per l'ambiente Go (come `go test`, `go mod`, ecc.) sono state rimosse o adattate per un contesto di programmazione in C.

---

# Lab 04 - char, stringhe, cicli annidati

## Problemi di base ricorrenti che richiedono l'iterazione

#### Trovate qui degli appunti e schemi di soluzioni per i problemi più comuni che richiedono l'uso dell'iterazione. (Il link resta invariato, ma gli schemi andranno interpretati in C).

## Test di base (blackbox testing)

Man mano che completate gli esercizi di scrittura, potete controllare che il formato dell'output sia corretto usando script di test o reindirizzando l'input da file e confrontando l'output con un file di output atteso.

#### Esempio di test manuale da terminale:
Supponiamo che il programma `mio_programma.c` debba essere testato con l'input salvato in `input.txt` e che l'output atteso sia in `output_atteso.txt`.

1.  **Compilare il programma:**
    ```sh
    gcc -o mio_programma mio_programma.c
    ```
2.  **Eseguire il programma con l'input reindirizzato e salvare l'output:**
    ```sh
    ./mio_programma < input.txt > mio_output.txt
    ```
3.  **Confrontare il proprio output con quello atteso:**
    ```sh
    diff mio_output.txt output_atteso.txt
    ```
    Se `diff` non produce alcun output, i file sono identici e il test è superato.

---

## Nota - lettura di caratteri
Per leggere un singolo carattere e salvarlo in una variabile `char carattere`, usare la funzione `scanf` della libreria `<stdio.h>`:
- `scanf(" %c", &carattere);`

**Importante:** Lo spazio prima di `%c` è fondamentale perché dice a `scanf` di ignorare eventuali caratteri di spaziatura (spazi, tab, a-capo) lasciati nel buffer di input da letture precedenti.

---

# Esercizi in C

Svolgere tutti gli esercizi, sia quelli di analisi e comprensione del codice sia quelli di scrittura, nell'ordine in cui sono proposti.

## Esercizi 0 e 1 di esempio
(non è richiesta la consegna online per questi esercizi)

### Es. 0
Scrivere un programma `es0.c` che fa le seguenti cose:
- legge un carattere (`char`)
- lo stampa
- stampa il carattere precedente, il carattere stesso, e quello successivo in ordine lessicografico (ASCII). Ad esempio, con 'd' come input, deve stampare: `c d e`
- stabilisce se è una lettera tra 'A' e 'L', o altro (stampa "A-L" o "altro")
- poi legge una stringa e la stampa in verticale, un carattere per riga.

Ad esempio, la stringa "citta" diventa:
```
c
i
t
t
a
```

### Es 1
Scrivere un programma `pos_alfabeto.c` che
- legge una sequenza di caratteri ASCII terminati da '.' (es: `abc!54LMN.`),
- per ciascun carattere letto (tranne '.'),
    - stabilisce se è una lettera minuscola (usando `islower()` da `<ctype.h>`), una cifra (`isdigit()`) o altro
    - se è una lettera minuscola, stabilisce anche la sua posizione nell'alfabeto (es. `c - 'a' + 1`)
    - se è una cifra, stabilisce il suo valore numerico (es. `c - '0'`)
    - stampa un messaggio costituito da:
        - il carattere letto
        - se minuscola, la sua posizione nell'alfabeto (es "f è la 6^a");
        - se cifra, il suo valore
        - altrimenti " - altro" (ad esempio "N - altro")
- quando termina, stampa la somma delle cifre e "bye"

Esempio di esecuzione

```
una sequenza di caratteri terminata da '.': abc!54LMN.
a è la 1^a
b è la 2^a
c è la 3^a
! - altro
5 - 5
4 - 4
L - altro
M - altro
N - altro
somma: 9
bye
```

---

## Esercizi di analisi e comprensione

I testi dei prossimi esercizi si trovano a questo [link](https://forms.gle/jpW2Au9oqgzP553f7).

Analizzate il codice (immaginandolo tradotto in C) e rispondete alle domande del form.

## Esercizi di scrittura guidata

I testi dei prossimi esercizi si trovano a questo [link](https://forms.gle/3gDTLytp12g1tDWd7).

Le domande che accompagnano ciascun esercizio servono per progettare la soluzione del problema posto prima di implementarla in C.
Prima di scrivere ciascun programma, rispondete alle domande e poi usate le vostre risposte per progettare il programma richiesto. I programmi sono poi da caricare sul sito di upload.

#### Lunghezza totale
nomefile: lunghezza_tot.c

#### Chars
nomefile: max_char.c

#### Trova
nomefile: trova.c

#### Stringa di byte
nomefile: stringaByte.c

#### Stringa multi-byte (ex "Stringa di rune")
*Nota: C non gestisce nativamente i caratteri multi-byte (Unicode) come Go. Questo esercizio va inteso come operante su stringhe standard C (sequenze di `char`).*

Scrivere un programma `stringaChar.c` che legge da standard input una stringa e la analizza carattere per carattere (`char`): stampa "+" quando il carattere considerato è maggiore (ha codice ASCII maggiore) del precedente, stampa "-" quando è minore e stampa "=" quando è uguale.

nomefile: stringaChar.c

---

## Esercizi di scrittura
(da consegnare secondo le istruzioni del corso)

**NOTA**: quando di un esercizio non sono mostrati esempi di esecuzione e nelle specifiche non è richiesta esplicitamente la stampa di messaggi per la richiesta dei dati in input, scrivete un programma in cui non sono presenti tali messaggi.

### Crescente
Scrivere un programma `crescente.c` che legge da standard input una stringa di sole lettere (ASCII) minuscole e la stampa inserendo un '-' ogni volta che una lettera viene prima in ordine alfabetico della lettera precedente.

Per esempio, data in input la parola `ambire`, il programma stampa
`am-bir-e`

nomefile: crescente.c

### Slash
Scrivere un programma `disegna_slash.c` che legge un intero positivo *n* e stampa un backslash (`\`) di altezza *n* composto da asterischi.

Esempio di esecuzione:

`dimensione \:` **3**
```
*
 *
  *
```

nomefile: disegna_slash.c

### V
Scrivere un programma `disegna_v.c` che legge un intero positivo *n* e stampa una 'v' di altezza (vertice compreso) *n* di asterischi.

Esempio di esecuzione:
`dimensione v:` **4**
```
*     *
 *   *
  * *
   *
```

nomefile: disegna_v.c

### Fibonacci
Scrivere un programma `fibonacci.c` che legge un intero positivo *n* e stampa i numeri di Fibonacci dal primo all'*n*-esimo, rappresentandoli come righe di asterischi, ciascuna lunga quanto il numero da rappresentare.

Esempio di esecuzione:

`un numero:` **6**
`*`
`*`
`**`
`***`
`*****`
`********`

**Nota.** I primi due numeri della serie di Fibonacci sono 1 e 1, dal terzo in poi sono ciascuno la somma dei due numeri che lo precedono nella serie. Quindi i primi numeri della serie sono: 1, 1, 2, 3, 5, 8, 13, 21, ...

nomefile: fibonacci.c

### MinuMaiu
Scrivere un programma `minu_maiu.c` che legge da standard input una stringa e stabilisce se la stringa contiene solo minuscole, solo maiuscole o sia minuscole che maiuscole, quindi stampa un messaggio opportuno (es. "solo minuscole", "solo maiuscole", "sia minuscole che maiuscole").
Utilizzare le funzioni della libreria `<ctype.h>` (es. `islower()`, `isupper()`).

nomefile: minu_maiu.c

---

## Composizione
Una volta identificati i sottoproblemi in un problema, occorre che le soluzioni dei sottoproblemi vengano composte insieme nel programma.

### Esempi di composizione

#### Concatenazione
Quando un sottoproblema non può essere risolto senza i risultati prodotti dalla soluzione di un altro sottoproblema, le loro soluzioni devono essere concatenate una dopo l'altra.

```c
/*
Specifiche: dato un numero intero in forma di stringa,
stampare le cifre che sono maggiori
della media delle cifre del numero.
*/
#include <stdio.h>
#include <string.h>

#define MAX_LEN 100

int main() {
    char numero[MAX_LEN];
    scanf("%s", numero);
    int dim = strlen(numero);

    // soluzione di due sottoproblemi (media e > media)
    // con due for separati, uno dopo l'altro

    // calcolo della media
    int sum = 0;
    for (int i = 0; i < dim; i++) {
        int n = numero[i] - '0';
        sum += n;
    }
    int media_val = sum / dim;
    char media_char = media_val + '0';
    printf("media %c\n", media_char);

    // stampa delle cifre maggiori della media
    for (int i = 0; i < dim; i++) {
        if (numero[i] > media_char) {
            printf("%c\n", numero[i]);
        }
    }
    return 0;
}
```

#### Fusione

Quando le soluzioni di sottoproblemi presentano alcune parti comuni che possono essere svolte insieme (es. max + min; somma + conteggio, ...), le soluzioni possono essere fuse insieme.
```c
/*
Specifiche: dato un numero intero >=0,
stampare la somma delle cifre e la cifra più grande
*/
#include <stdio.h>

int main() {
    int num, max = 0;
    printf("un int >=0: ");
    scanf("%d", &num);

    // soluzione di due sottoproblemi (somma e max)
    // con un unico ciclo
    int sum = 0;
    while (num > 0) {
        int cifra = num % 10;
        sum += cifra;     // calcolo della somma
        if (cifra > max) { // determinazione del max
            max = cifra;
        }
        num /= 10;
    }
    printf("somma: %d\n", sum);
    printf("max: %d\n", max);
    return 0;
}
```

#### Annidamento

Quando la soluzione di un problema che richiede un ciclo ha come sottoproblema a sua volta un problema che richiede un ciclo, le soluzioni vanno composte annidando i rispettivi cicli.
```c
/*
Specifiche: data una serie di 10 numeri interi,
stampare il primo numero la cui somma delle cifre è pari
*/
#include <stdio.h>

int main() {
    const int DIM = 10;
    int num;

    // soluzione di due sottoproblemi con due for, uno annidato nell'altro

    for (int i = 0; i < DIM; i++) { // for esterno per la ricerca sugli input
        printf("next int: ");
        scanf("%d", &num);
        int sum = 0;    // riazzero la somma per ogni nuovo numero
        int n = num;    // faccio una copia del numero
        while (n > 0) { // ciclo interno per la somma
            int cifra = n % 10;
            sum += cifra;
            n /= 10;
        }
        // if per interrompere la ricerca (for esterno)
        if (sum % 2 == 0) { // verifica se la somma è pari
            printf("%d\n", num);
            break;
        }
    }
    return 0;
}
```
---

### Max somma cifre
Si vuole scrivere un programma `max_somma_cifre.c` che
- legge da standard input una serie di numeri >= 0, terminata da 999,
- trova il numero (escludendo 999) la cui somma delle cifre è la maggiore
- e stampa tale somma.

Copiare il seguente codice in un file `max_somma_cifre.c` e completarlo in modo che rispetti le specifiche date qui sopra.

Si noti che il programma contiene due cicli annidati, uno servirà per determinare un massimo e uno per calcolare una somma.

```c
#include <stdio.h>

int main() {
    int n;
    int maxSum = 0;

    for (;;) { // o while(1)
        scanf("%d", &n);
        if (n == 999) {
            break;
        }
        // ... calcola la somma delle cifre di n
        int currentSum = 0;
        int temp_n = n;
        while (/* ... */) {
            // ...
        }

        if (/* ... la somma corrente è maggiore della massima trovata finora? */) {
            // ... aggiorna maxSum
        }
    }
    printf("%d\n", maxSum);
    return 0;
}
```

nomefile: max_somma_cifre.c

---

### Numero di occorrenze del massimo
Scrivere un programma `num_max.c` che legge una sequenza di 10 interi positivi e stampa il massimo intero letto e quante volte tale massimo compare nella sequenza.

È possibile risolvere il problema senza memorizzare la sequenza in un array. Che tipo di composizione (concatenazione, fusione, annidamento) occorrerà per determinare insieme il calcolo del massimo e il conteggio delle occorrenze?

nomefile: num_max.c

---

### Massimo numero di cifre pari
Scrivere un programma `max_num_cifre_pari.c` che, data una sequenza di numeri (da leggere come stringhe), terminata dalla stringa "000", stampa il numero di cifre pari contenute nel numero che ne contiene più di tutti.
Per confrontare le stringhe, usare `strcmp` dalla libreria `<string.h>`.

È possibile risolvere il problema senza memorizzare la sequenza di numeri. Che tipo di composizione occorrerà per mettere insieme il conteggio delle cifre pari e il calcolo del massimo di tali conteggi?

nomefile: max_num_cifre_pari.c

---

## Problemi

### Cesare
Scrivere un programma `cesare.c` che legge da standard input un numero intero non negativo *k* (la chiave di cifratura), e poi una sequenza di lettere ASCII minuscole sulla stessa riga, e cifra le lettere lette con il cifrario di Cesare, usando come chiave *k*. Stampa il testo cifrato. Ogni lettera del testo in chiaro è sostituita nel testo cifrato dalla lettera che si trova *k* posizioni dopo nell'alfabeto, ritornando alla lettera 'a' dopo la 'z' (operazione modulo).

Esempi di esecuzione:

**2 zaprb**
`bcrtd`

**100 abcd**
`wxyz`

---

nomefile: cesare.c

### L'ultimo giorno di pioggia
Scrivere un programma `ultima_pioggia.c` che legge da standard input una sequenza di numeri interi (terminata da EOF) che indicano i mm di pioggia caduti (`>= 0`) ogni giorno in una sequenza successiva di giorni (numerati a partire da 1) e stampa l'ultimo giorno in cui ha piovuto (cioè l'ultimo giorno con pioggia > 0).

**Nota** su come gestire la lettura fino a EOF (End-Of-File):
`scanf` restituisce il numero di elementi letti correttamente. Quando non c'è più input da leggere, restituisce `EOF`. Un ciclo tipico è:
```c
int valore;
while (scanf("%d", &valore) != EOF) {
    // elabora valore...
}
```
Da tastiera, si può inviare `EOF` con `Ctrl+D` (su Linux/macOS) o `Ctrl+Z` seguito da Invio (su Windows).

nomefile: ultima_pioggia.c

### Sottosequenze
Scrivere un programma `num_sequenze.c` che legge da standard input una sequenza di uni (1) e zeri (0) (terminata da un 2), che inizia e finisce con 1, e stampa il numero di sottosequenze di zeri.

Ad esempio per input `1 1 0 0 1 0 1 0 0 0 1 1 1 0 1 2`, l'output è 4.

nomefile: num_sequenze.c

### Gradini
Definiamo "gradino" una sequenza di (uno o più) interi non negativi uguali seguita da un'altra sequenza di (uno o più) interi più grandi di 1 (es. `1 1 2 2 2`).

Scrivere un programma `maxGradino.c` che, data in input una sequenza di interi tali che ogni intero è `>=` del precedente, stampa la lunghezza (il numero di interi) del gradino più lungo. (Si noti che i gradini si sovrappongono).

Il programma termina quando legge un numero minore di quello appena letto.

Potete dare per scontato che i numeri in input rispettino la condizione; non occorre fare controlli.

Per input `2 2 3 3 4 4 4 5 6 6 6 7 2`, l'output è 5 (il gradino `3 3 4 4 4`).

nomefile: maxGradino.c
